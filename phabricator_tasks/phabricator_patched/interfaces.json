{
    "almanac.device.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "almanac.service.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "audit.query": {
        "description": "Query audit requests.",
        "params": {
            "auditorPHIDs": "optional list<phid>",
            "commitPHIDs": "optional list<phid>",
            "status": "optional string-constant<\"audit-status-any\", \"audit-status-open\", \"audit-status-concern\", \"audit-status-accepted\", \"audit-status-partial\"> (default = \"audit-status-any\")",
            "offset": "optional int",
            "limit": "optional int (default = 100)"
        },
        "return": "list<dict>"
    },
    "auth.logout": {
        "description": "Terminate all web login sessions. If called via OAuth, also terminate the current OAuth token.\n\nWARNING: This method does what it claims on the label. If you call this method via the test console in the web UI, it will log you out!",
        "params": [],
        "return": "void"
    },
    "auth.querypublickeys": {
        "description": "Query public keys.",
        "params": {
            "ids": "optional list<id>",
            "phids": "optional list<phid>",
            "objectPHIDs": "optional list<phid>",
            "keys": "optional list<string>",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "result-set"
    },
    "badges.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "badges.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "conduit.connect": {
        "description": "Connect a session-based client.",
        "params": {
            "client": "required string",
            "clientVersion": "required int",
            "clientDescription": "optional string",
            "user": "optional string",
            "authToken": "optional int",
            "authSignature": "optional string",
            "host": "deprecated"
        },
        "return": "dict<string, any>"
    },
    "conduit.getcapabilities": {
        "description": "List capabilities, wire formats, and authentication protocols available on this server.",
        "params": [],
        "return": "dict<string, any>"
    },
    "conduit.getcertificate": {
        "description": "Retrieve certificate information for a user.",
        "params": {
            "token": "required string",
            "host": "required string"
        },
        "return": "dict<string, any>"
    },
    "conduit.ping": {
        "description": "Basic ping for monitoring or a health-check.",
        "params": [],
        "return": "string"
    },
    "conduit.query": {
        "description": "Returns the parameters of the Conduit methods.",
        "params": [],
        "return": "dict<dict>"
    },
    "conpherence.createthread": {
        "description": "Create a new conpherence thread.",
        "params": {
            "title": "optional string",
            "message": "required string",
            "participantPHIDs": "required list<phids>"
        },
        "return": "nonempty dict"
    },
    "conpherence.querythread": {
        "description": "Query for Conpherence threads for the logged in user. You can query by IDs or PHIDs for specific Conpherence threads. Otherwise, specify limit and offset to query the most recently updated Conpherences for the logged in user.",
        "params": {
            "ids": "optional array<int>",
            "phids": "optional array<phids>",
            "limit": "optional int",
            "offset": "optional int"
        },
        "return": "nonempty dict"
    },
    "conpherence.querytransaction": {
        "description": "Query for transactions for the logged in user within a specific Conpherence room. You can specify the room by ID or PHID. Otherwise, specify limit and offset to query the most recent transactions within the Conpherence room for the logged in user.",
        "params": {
            "roomID": "optional int",
            "roomPHID": "optional phid",
            "limit": "optional int",
            "offset": "optional int"
        },
        "return": "nonempty dict"
    },
    "conpherence.updatethread": {
        "description": "Update an existing conpherence room.",
        "params": {
            "id": "optional int",
            "phid": "optional phid",
            "title": "optional string",
            "message": "optional string",
            "addParticipantPHIDs": "optional list<phids>",
            "removeParticipantPHID": "optional phid"
        },
        "return": "bool"
    },
    "dashboard.panel.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "differential.close": {
        "description": "Close a Differential revision.",
        "params": {
            "revisionID": "required int"
        },
        "return": "void"
    },
    "differential.createcomment": {
        "description": "Add a comment to a Differential revision.",
        "params": {
            "revision_id": "required revisionid",
            "message": "optional string",
            "action": "optional string",
            "silent": "optional bool",
            "attach_inlines": "optional bool"
        },
        "return": "nonempty dict"
    },
    "differential.creatediff": {
        "description": "Create a new Differential diff.",
        "params": {
            "changes": "required list<dict>",
            "sourceMachine": "required string",
            "sourcePath": "required string",
            "branch": "required string",
            "bookmark": "optional string",
            "sourceControlSystem": "required string-constant<\"svn\", \"git\", \"hg\">",
            "sourceControlPath": "required string",
            "sourceControlBaseRevision": "required string",
            "creationMethod": "optional string",
            "lintStatus": "required string-constant<\"none\", \"skip\", \"okay\", \"warn\", \"fail\">",
            "unitStatus": "required string-constant<\"none\", \"skip\", \"okay\", \"warn\", \"fail\">",
            "repositoryPHID": "optional phid",
            "parentRevisionID": "deprecated",
            "authorPHID": "deprecated",
            "repositoryUUID": "deprecated"
        },
        "return": "nonempty dict"
    },
    "differential.createinline": {
        "description": "Add an inline comment to a Differential revision.",
        "params": {
            "revisionID": "optional revisionid",
            "diffID": "optional diffid",
            "filePath": "required string",
            "isNewFile": "required bool",
            "lineNumber": "required int",
            "lineLength": "optional int",
            "content": "required string"
        },
        "return": "nonempty dict"
    },
    "differential.createrawdiff": {
        "description": "Create a new Differential diff from a raw diff source.",
        "params": {
            "diff": "required string",
            "repositoryPHID": "optional string",
            "viewPolicy": "optional string"
        },
        "return": "nonempty dict"
    },
    "differential.createrevision": {
        "description": "Create a new Differential revision.",
        "params": {
            "user": "ignored",
            "diffid": "required diffid",
            "fields": "required dict"
        },
        "return": "nonempty dict"
    },
    "differential.getcommitmessage": {
        "description": "Retrieve Differential commit messages or message templates.",
        "params": {
            "revision_id": "optional revision_id",
            "fields": "optional dict<string, wild>",
            "edit": "optional string-constant<\"edit\", \"create\">"
        },
        "return": "nonempty string"
    },
    "differential.getcommitpaths": {
        "description": "Query which paths should be included when committing a Differential revision.",
        "params": {
            "revision_id": "required int"
        },
        "return": "nonempty list<string>"
    },
    "differential.getrawdiff": {
        "description": "Retrieve a raw diff",
        "params": {
            "diffID": "required diffID"
        },
        "return": "nonempty string"
    },
    "differential.parsecommitmessage": {
        "description": "Parse commit messages for Differential fields.",
        "params": {
            "corpus": "required string",
            "partial": "optional bool"
        },
        "return": "nonempty dict"
    },
    "differential.query": {
        "description": "Query Differential revisions which match certain criteria.",
        "params": {
            "authors": "optional list<phid>",
            "ccs": "optional list<phid>",
            "reviewers": "optional list<phid>",
            "paths": "optional list<pair<callsign, path>>",
            "commitHashes": "optional list<pair<string-constant<\"gtcm\", \"gttr\", \"hgcm\">, string>>",
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-accepted\", \"status-closed\">",
            "order": "optional string-constant<\"order-modified\", \"order-created\">",
            "limit": "optional uint",
            "offset": "optional uint",
            "ids": "optional list<uint>",
            "phids": "optional list<phid>",
            "subscribers": "optional list<phid>",
            "responsibleUsers": "optional list<phid>",
            "branches": "optional list<string>"
        },
        "return": "list<dict>"
    },
    "differential.querydiffs": {
        "description": "Query differential diffs which match certain criteria.",
        "params": {
            "ids": "optional list<uint>",
            "revisionIDs": "optional list<uint>"
        },
        "return": "list<dict>"
    },
    "differential.setdiffproperty": {
        "description": "Attach properties to Differential diffs.",
        "params": {
            "diff_id": "required diff_id",
            "name": "required string",
            "data": "required string"
        },
        "return": "void"
    },
    "differential.updaterevision": {
        "description": "Update a Differential revision.",
        "params": {
            "id": "required revisionid",
            "diffid": "required diffid",
            "fields": "required dict",
            "message": "required string"
        },
        "return": "nonempty dict"
    },
    "differential.revision.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "differential.find": {
        "description": "Query Differential revisions which match certain criteria.",
        "params": {
            "query": "required string-constant<\"open\", \"committable\", \"revision-ids\", \"phids\">",
            "guids": "required nonempty list<guids>"
        },
        "return": "nonempty list<dict>"
    },
    "differential.getalldiffs": {
        "description": "Load all diffs for given revisions from Differential.",
        "params": {
            "revision_ids": "required list<int>"
        },
        "return": "dict"
    },
    "differential.getdiff": {
        "description": "Load the content of a diff from Differential by revision ID or diff ID.",
        "params": {
            "revision_id": "optional id",
            "diff_id": "optional id"
        },
        "return": "nonempty dict"
    },
    "differential.getrevision": {
        "description": "Load the content of a revision from Differential.",
        "params": {
            "revision_id": "required id"
        },
        "return": "nonempty dict"
    },
    "differential.getrevisioncomments": {
        "description": "Retrieve Differential Revision Comments.",
        "params": {
            "ids": "required list<int>",
            "inlines": "optional bool (deprecated)"
        },
        "return": "nonempty list<dict<string, wild>>"
    },
    "diffusion.commit.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "after": "optional string",
            "attachments": "optional map<string, bool>",
            "before": "optional string",
            "constraints": "optional map<string, wild>",
            "limit": "optional int (default = 100)",
            "order": "optional order",
            "queryKey": "optional string"
        },
        "return": "list<string>"
    },
    "diffusion.findsymbols": {
        "description": "Retrieve Diffusion symbol information.",
        "params": {
            "name": "optional string",
            "namePrefix": "optional string",
            "context": "optional string",
            "language": "optional string",
            "type": "optional string",
            "repositoryPHID": "optional string"
        },
        "return": "nonempty list<dict>"
    },
    "diffusion.getrecentcommitsbypath": {
        "description": "Get commit identifiers for recent commits affecting a given path.",
        "params": {
            "callsign": "required string",
            "path": "required string",
            "branch": "optional string",
            "limit": "optional int"
        },
        "return": "nonempty list<string>"
    },
    "diffusion.querycommits": {
        "description": "Retrieve information about commits.",
        "params": {
            "ids": "optional list<int>",
            "phids": "optional list<phid>",
            "names": "optional list<string>",
            "repositoryPHID": "optional phid",
            "needMessages": "optional bool",
            "bypassCache": "optional bool",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, dict>"
    },
    "diffusion.blame": {
        "description": "Get blame information for a list of paths.",
        "params": {
            "paths": "required list<string>",
            "commit": "required string",
            "timeout": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "map<string, wild>"
    },
    "diffusion.branchquery": {
        "description": "Determine what branches exist for a repository.",
        "params": {
            "closed": "optional bool",
            "limit": "optional int",
            "offset": "optional int",
            "contains": "optional string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "list<dict>"
    },
    "diffusion.browsequery": {
        "description": "File(s) information for a repository at an (optional) path and (optional) commit.",
        "params": {
            "path": "optional string",
            "commit": "optional string",
            "needValidityOnly": "optional bool",
            "limit": "optional int",
            "offset": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.commitparentsquery": {
        "description": "Get the commit identifiers for a commit's parent or parents.",
        "params": {
            "commit": "required string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "list<string>"
    },
    "diffusion.diffquery": {
        "description": "Get diff information from a repository for a specific path at an (optional) commit.",
        "params": {
            "path": "required string",
            "commit": "optional string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.existsquery": {
        "description": "Determine if code exists in a version control system.",
        "params": {
            "commit": "required string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "bool"
    },
    "diffusion.filecontentquery": {
        "description": "Retrieve file content from a repository.",
        "params": {
            "path": "required string",
            "commit": "required string",
            "timeout": "optional int",
            "byteLimit": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.getlintmessages": {
        "description": "Get lint messages for existing code.",
        "params": {
            "repositoryPHID": "required phid",
            "branch": "required string",
            "commit": "optional string",
            "files": "required list<string>"
        },
        "return": "list<dict>"
    },
    "diffusion.historyquery": {
        "description": "Returns history information for a repository at a specific commit and path.",
        "params": {
            "commit": "required string",
            "path": "required string",
            "offset": "required int",
            "limit": "required int",
            "needDirectChanges": "optional bool",
            "needChildChanges": "optional bool",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.internal.gitrawdiffquery": {
        "description": "Internal method for getting raw diff information.",
        "params": {
            "commit": "required string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "string"
    },
    "diffusion.lastmodifiedquery": {
        "description": "Get the commits at which paths were last modified.",
        "params": {
            "paths": "required map<string, string>",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "map<string, string>"
    },
    "diffusion.looksoon": {
        "description": "Advises Phabricator to look for new commits in a repository as soon as possible. This advice is most useful if you have just pushed new commits to that repository.",
        "params": {
            "callsigns": "optional list<string> (deprecated)",
            "repositories": "optional list<string>",
            "urgency": "optional string"
        },
        "return": "void"
    },
    "diffusion.mergedcommitsquery": {
        "description": "Merged commit information for a specific commit in a repository.",
        "params": {
            "commit": "required string",
            "limit": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.querypaths": {
        "description": "Filename search on a repository.",
        "params": {
            "path": "required string",
            "commit": "required string",
            "pattern": "optional string",
            "limit": "optional int",
            "offset": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "list<string>"
    },
    "diffusion.rawdiffquery": {
        "description": "Get raw diff information from a repository for a specific commit at an (optional) path.",
        "params": {
            "commit": "required string",
            "path": "optional string",
            "timeout": "optional int",
            "byteLimit": "optional int",
            "linesOfContext": "optional int",
            "againstCommit": "optional string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "string"
    },
    "diffusion.refsquery": {
        "description": "Query a git repository for ref information at a specific commit.",
        "params": {
            "commit": "required string",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.repository.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "diffusion.repository.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "diffusion.resolverefs": {
        "description": "Resolve references into stable, canonical identifiers.",
        "params": {
            "refs": "required list<string>",
            "types": "optional list<string>",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "dict<string, list<dict<string, wild>>>"
    },
    "diffusion.searchquery": {
        "description": "Search (grep) a repository at a specific path and commit.",
        "params": {
            "path": "required string",
            "commit": "optional string",
            "grep": "required string",
            "limit": "optional int",
            "offset": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.tagsquery": {
        "description": "Retrieve information about tags in a repository.",
        "params": {
            "names": "optional list<string>",
            "commit": "optional string",
            "needMessages": "optional bool",
            "offset": "optional int",
            "limit": "optional int",
            "callsign": "optional string (deprecated)",
            "repository": "optional string",
            "branch": "optional string"
        },
        "return": "array"
    },
    "diffusion.updatecoverage": {
        "description": "Publish coverage information for a repository.",
        "params": {
            "repositoryPHID": "required phid",
            "branch": "required string",
            "commit": "required string",
            "coverage": "required map<string, string>",
            "mode": "optional string-constant<\"overwrite\", \"update\">"
        },
        "return": "void"
    },
    "diffusion.uri.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "diffusion.createcomment": {
        "description": "Add a comment to a Diffusion commit. By specifying an action of \"concern\", \"accept\", \"resign\", or \"close\", auditing actions can be triggered. Defaults to \"comment\".",
        "params": {
            "phid": "required string",
            "action": "optional string",
            "message": "required string",
            "silent": "optional bool"
        },
        "return": "bool"
    },
    "feed.publish": {
        "description": "Publish a story to the feed.",
        "params": {
            "type": "required string",
            "data": "required dict",
            "time": "optional int"
        },
        "return": "nonempty phid"
    },
    "feed.query": {
        "description": "Query the feed for stories",
        "params": {
            "filterPHIDs": "optional list <phid>",
            "limit": "optional int (default 100)",
            "after": "optional int",
            "before": "optional int",
            "view": "optional string (data, html, html-summary, text)"
        },
        "return": "nonempty dict"
    },
    "file.allocate": {
        "description": "Prepare to upload a file.",
        "params": {
            "name": "string",
            "contentLength": "int",
            "contentHash": "optional string",
            "viewPolicy": "optional string",
            "deleteAfterEpoch": "optional int"
        },
        "return": "map<string, wild>"
    },
    "file.download": {
        "description": "Download a file from the server.",
        "params": {
            "phid": "required phid"
        },
        "return": "nonempty base64-bytes"
    },
    "file.info": {
        "description": "Get information about a file.",
        "params": {
            "phid": "optional phid",
            "id": "optional id"
        },
        "return": "nonempty dict"
    },
    "file.querychunks": {
        "description": "Get information about file chunks.",
        "params": {
            "filePHID": "phid"
        },
        "return": "list<wild>"
    },
    "file.upload": {
        "description": "Upload a file to the server.",
        "params": {
            "data_base64": "required nonempty base64-bytes",
            "name": "optional string",
            "viewPolicy": "optional valid policy string or <phid>",
            "canCDN": "optional bool"
        },
        "return": "nonempty guid"
    },
    "file.uploadchunk": {
        "description": "Upload a chunk of file data to the server.",
        "params": {
            "filePHID": "phid",
            "byteStart": "int",
            "data": "string",
            "dataEncoding": "string"
        },
        "return": "void"
    },
    "file.uploadhash": {
        "description": "Upload a file to the server using content hash.",
        "params": {
            "hash": "required nonempty string",
            "name": "required nonempty string"
        },
        "return": "phid or null"
    },
    "flag.delete": {
        "description": "Clear a flag.",
        "params": {
            "id": "optional id",
            "objectPHID": "optional phid"
        },
        "return": "dict | null"
    },
    "flag.edit": {
        "description": "Create or modify a flag.",
        "params": {
            "objectPHID": "required phid",
            "color": "optional int",
            "note": "optional string"
        },
        "return": "dict"
    },
    "flag.query": {
        "description": "Query flag markers.",
        "params": {
            "ownerPHIDs": "optional list<phid>",
            "types": "optional list<type>",
            "objectPHIDs": "optional list<phid>",
            "offset": "optional int",
            "limit": "optional int (default = 100)"
        },
        "return": "list<dict>"
    },
    "harbormaster.createartifact": {
        "description": "Use this method to attach artifacts to build targets while running builds. Artifacts can be used to carry data through a complex build workflow, provide extra information to users, or store build results.\n\nWhen creating an artifact, you will choose an `artifactType` from this table. These types of artifacts are supported:\n| Artifact Type | Name | Summary |\n|-------------|--------------|--------------|\n| `host` | **Drydock Host** | References a host lease from Drydock. |\n| `working-copy` | **Drydock Working Copy** | References a working copy lease from Drydock. |\n| `file` | **File** | Stores a reference to file data which has been uploaded to Phabricator. |\n| `uri` | **URI** | Stores a URI. |\n\nEach artifact also needs an `artifactKey`, which names the artifact. Finally, you will provide some `artifactData` to fill in the content of the artifact. The data you provide depends on what type of artifact you are creating.\nDrydock Host\n--------------------------\n\nReferences a host lease from Drydock.\n\nCreate an artifact of this type by passing `host` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `drydockLeasePHID` | //string// | Drydock working copy lease to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"drydockLeasePHID\": \"PHID-DRYL-abcdefghijklmnopqrst\"\n}\n\n```\nDrydock Working Copy\n--------------------------\n\nReferences a working copy lease from Drydock.\n\nCreate an artifact of this type by passing `working-copy` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `drydockLeasePHID` | //string// | Drydock working copy lease to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"drydockLeasePHID\": \"PHID-DRYL-abcdefghijklmnopqrst\"\n}\n\n```\nFile\n--------------------------\n\nStores a reference to file data which has been uploaded to Phabricator.\n\nCreate an artifact of this type by passing `file` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `filePHID` | //string// | File to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"filePHID\": \"PHID-FILE-abcdefghijklmnopqrst\"\n}\n\n```\nURI\n--------------------------\n\nStores a URI.\n\nWith `ui.external`, you can use this artifact type to add links to build results in an external build system.\n\nCreate an artifact of this type by passing `uri` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `uri` | //string// | The URI to store. |\n| `name` | //optional string// | Optional label for this URI. |\n| `ui.external` | //optional bool// | If true, display this URI in the UI as an link to additional build details in an external build system. |\nFor example:\n```lang=json\n{\n  \"uri\": \"https://buildserver.mycompany.com/build/123/\",\n  \"name\": \"View External Build Results\",\n  \"ui.external\": true\n}\n\n```",
        "params": {
            "buildTargetPHID": "phid",
            "artifactKey": "string",
            "artifactType": "string",
            "artifactData": "map<string, wild>"
        },
        "return": "wild"
    },
    "harbormaster.queryautotargets": {
        "description": "Load or create build autotargets.",
        "params": {
            "objectPHID": "phid",
            "targetKeys": "list<string>"
        },
        "return": "map<string, phid>"
    },
    "harbormaster.querybuildables": {
        "description": "Query Harbormaster buildables.",
        "params": {
            "ids": "optional list<id>",
            "phids": "optional list<phid>",
            "buildablePHIDs": "optional list<phid>",
            "containerPHIDs": "optional list<phid>",
            "manualBuildables": "optional bool",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "wild"
    },
    "harbormaster.querybuilds": {
        "description": "Query Harbormaster builds.",
        "params": {
            "ids": "optional list<id>",
            "phids": "optional list<phid>",
            "buildStatuses": "optional list<string>",
            "buildablePHIDs": "optional list<phid>",
            "buildPlanPHIDs": "optional list<phid>",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "wild"
    },
    "harbormaster.sendmessage": {
        "description": "Send a message about the status of a build target to Harbormaster, notifying the application of build results in an external system.\n\nSending Messages\n================\nIf you run external builds, you can use this method to publish build results back into Harbormaster after the external system finishes work or as it makes progress.\n\nThe simplest way to use this method is to call it once after the build finishes with a `pass` or `fail` message. This will record the build result, and continue the next step in the build if the build was waiting for a result.\n\nWhen you send a status message about a build target, you can optionally include detailed `lint` or `unit` results alongside the message. See below for details.\n\nIf you want to report intermediate results but a build hasn't completed yet, you can use the `work` message. This message doesn't have any direct effects, but allows you to send additional data to update the progress of the build target. The target will continue waiting for a completion message, but the UI will update to show the progress which has been made.\n\nMessage Types\n=============\nWhen you send Harbormaster a message, you must include a `type`, which describes the overall state of the build. For example, use `pass` to tell Harbomaster that a build completed successfully.\n\nSupported message types are:\n\n| Type | Description |\n|--------------|--------------|\n| `pass` | Report that the target is complete, and the target has passed. |\n| `fail` | Report that the target is complete, and the target has failed. |\n| `work` | Report that work on the target is ongoing. This message can be used to report partial results during a build. |\n\nUnit Results\n============\nYou can report test results alongside a message. The simplest way to do this is to report all the results alongside a `pass` or `fail` message, but you can also send a `work` message to report intermediate results.\n\nTo provide unit test results, pass a list of results in the `unit` parameter. Each result shoud be a dictionary with these keys:\n\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `name` | //string// | Short test name, like \"ExampleTest\". |\n| `result` | //string// | Result of the test. |\n| `namespace` | //optional string// | Optional namespace for this test. This is organizational and is often a class or module name, like \"ExampleTestCase\". |\n| `engine` | //optional string// | Test engine running the test, like \"JavascriptTestEngine\". This primarily prevents collisions between tests with the same name in different test suites (for example, a Javascript test and a Python test). |\n| `duration` | //optional float or int// | Runtime duration of the test, in seconds. |\n| `path` | //optional string// | Path to the file where the test is declared, relative to the project root. |\n| `coverage` | //optional map<string, wild>// | Coverage information for this test. |\n| `details` | //optional string// | Additional human-readable information about the failure. |\n\nThe `result` parameter recognizes these test results:\n\n| Key | Name | Description |\n|-------------|--------------|--------------|\n| `pass` | **Pass** | The test passed. |\n| `fail` | **Fail** | The test failed. |\n| `skip` | **Skip** | The test was not executed. |\n| `broken` | **Broken** | The test failed in an abnormal or severe way. For example, the harness crashed instead of reporting a failure. |\n| `unsound` | **Unsound** | The test failed, but this change is probably not what broke it. For example, it might have already been failing. |\n\nThis is a simple, valid value for the `unit` parameter. It reports one passing test and one failing test:\n\n\n\n```lang=json\n[\n  {\n    \"name\": \"PassingTest\",\n    \"result\": \"pass\"\n  },\n  {\n    \"name\": \"FailingTest\",\n    \"result\": \"fail\"\n  }\n]\n```\n\nLint Results\n============\nLike unit test results, you can report lint results alongside a message. The `lint` parameter should contain results as a list of dictionaries with these keys:\n\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `name` | //string// | Short message name, like \"Syntax Error\". |\n| `code` | //string// | Lint message code identifying the type of message, like \"ERR123\". |\n| `severity` | //string// | Severity of the message. |\n| `path` | //string// | Path to the file containing the lint message, from the project root. |\n| `line` | //optional int// | Line number in the file where the text which triggered the message first appears. The first line of the file is line 1, not line 0. |\n| `char` | //optional int// | Byte position on the line where the text which triggered the message starts. The first byte on the line is byte 1, not byte 0. This position is byte-based (not character-based) because not all lintable files have a valid character encoding. |\n| `description` | //optional string// | Long explanation of the lint message. |\n\nThe `severity` parameter recognizes these severity levels:\n\n| Key | Name |\n|-------------|--------------|\n| `advice` | **Advice** |\n| `autofix` | **Auto-Fix** |\n| `warning` | **Warning** |\n| `error` | **Error** |\n| `disabled` | **Disabled** |\n\nThis is a simple, valid value for the `lint` parameter. It reports one error and one warning:\n\n```lang=json\n[\n  {\n    \"name\": \"Syntax Error\",\n    \"code\": \"EXAMPLE1\",\n    \"severity\": \"error\",\n    \"path\": \"path/to/example.c\",\n    \"line\": 17,\n    \"char\": 3\n  },\n  {\n    \"name\": \"Not A Haiku\",\n    \"code\": \"EXAMPLE2\",\n    \"severity\": \"error\",\n    \"path\": \"path/to/source.cpp\",\n    \"line\": 23,\n    \"char\": 1,\n    \"description\": \"This function definition is not a haiku.\"\n  }\n]\n```\n\n",
        "params": {
            "buildTargetPHID": "required phid",
            "type": "required string-constant<\"pass\", \"fail\", \"work\">",
            "unit": "optional list<wild>",
            "lint": "optional list<wild>"
        },
        "return": "void"
    },
    "macro.query": {
        "description": "Retrieve image macro information.",
        "params": {
            "authorPHIDs": "optional list<phid>",
            "phids": "optional list<phid>",
            "ids": "optional list<id>",
            "names": "optional list<string>",
            "nameLike": "optional string"
        },
        "return": "list<dict>"
    },
    "macro.creatememe": {
        "description": "Generate a meme.",
        "params": {
            "macroName": "string",
            "upperText": "optional string",
            "lowerText": "optional string"
        },
        "return": "string"
    },
    "maniphest.createtask": {
        "description": "Create a new Maniphest task.",
        "params": {
            "title": "required string",
            "description": "optional string",
            "ownerPHID": "optional phid",
            "viewPolicy": "optional phid or policy string",
            "editPolicy": "optional phid or policy string",
            "ccPHIDs": "optional list<phid>",
            "priority": "optional int",
            "projectPHIDs": "optional list<phid>",
            "auxiliary": "optional dict"
        },
        "return": "nonempty dict"
    },
    "maniphest.gettasktransactions": {
        "description": "Retrieve Maniphest task transactions.",
        "params": {
            "ids": "required list<int>"
        },
        "return": "nonempty list<dict<string, wild>>"
    },
    "maniphest.info": {
        "description": "Retrieve information about a Maniphest task, given its ID.",
        "params": {
            "task_id": "required id"
        },
        "return": "nonempty dict"
    },
    "maniphest.query": {
        "description": "Execute complex searches for Maniphest tasks.",
        "params": {
            "ids": "optional list<uint>",
            "phids": "optional list<phid>",
            "ownerPHIDs": "optional list<phid>",
            "authorPHIDs": "optional list<phid>",
            "projectPHIDs": "optional list<phid>",
            "ccPHIDs": "optional list<phid>",
            "fullText": "optional string",
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-closed\", \"status-resolved\", \"status-wontfix\", \"status-invalid\", \"status-spite\", \"status-duplicate\">",
            "order": "optional string-constant<\"order-priority\", \"order-created\", \"order-modified\">",
            "limit": "optional int",
            "offset": "optional int"
        },
        "return": "list"
    },
    "maniphest.querystatuses": {
        "description": "Retrieve information about possible Maniphest task status values.",
        "params": [],
        "return": "nonempty dict<string, wild>"
    },
    "maniphest.update": {
        "description": "Update an existing Maniphest task.",
        "params": {
            "id": "optional int",
            "phid": "optional int",
            "title": "optional string",
            "description": "optional string",
            "ownerPHID": "optional phid",
            "viewPolicy": "optional phid or policy string",
            "editPolicy": "optional phid or policy string",
            "ccPHIDs": "optional list<phid>",
            "priority": "optional int",
            "projectPHIDs": "optional list<phid>",
            "auxiliary": "optional dict",
            "status": "optional string",
            "comments": "optional string"
        },
        "return": "nonempty dict"
    },
    "maniphest.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "maniphest.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "owners.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "owners.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "owners.query": {
        "description": "Query for Owners packages. Obsoleted by \"owners.search\".",
        "params": {
            "userOwner": "optional string",
            "projectOwner": "optional string",
            "userAffiliated": "optional string",
            "repositoryCallsign": "optional string",
            "path": "optional string"
        },
        "return": "dict<phid -> dict of package info>"
    },
    "passphrase.query": {
        "description": "Query credentials.",
        "params": {
            "ids": "optional list<int>",
            "phids": "optional list<phid>",
            "needSecrets": "optional bool",
            "needPublicKeys": "optional bool",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "list<dict>"
    },
    "paste.create": {
        "description": "Create a new paste.",
        "params": {
            "content": "required string",
            "title": "optional string",
            "language": "optional string"
        },
        "return": "nonempty dict"
    },
    "paste.query": {
        "description": "Query Pastes.",
        "params": {
            "ids": "optional list<int>",
            "phids": "optional list<phid>",
            "authorPHIDs": "optional list<phid>",
            "after": "optional int",
            "limit": "optional int, default = 100"
        },
        "return": "list<dict>"
    },
    "paste.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "paste.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "paste.info": {
        "description": "Retrieve an array of information about a paste.",
        "params": {
            "paste_id": "required id"
        },
        "return": "nonempty dict"
    },
    "phame.blog.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "phame.blog.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "phame.post.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "phame.post.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "phid.lookup": {
        "description": "Look up objects by name.",
        "params": {
            "names": "required list<string>"
        },
        "return": "nonempty dict<string, wild>"
    },
    "phid.query": {
        "description": "Retrieve information about arbitrary PHIDs.",
        "params": {
            "phids": "required list<phid>"
        },
        "return": "nonempty dict<string, wild>"
    },
    "phid.info": {
        "description": "Retrieve information about an arbitrary PHID.",
        "params": {
            "phid": "required phid"
        },
        "return": "nonempty dict<string, wild>"
    },
    "phragment.getpatch": {
        "description": "Retrieve the patches to apply for a given set of files.",
        "params": {
            "path": "required string",
            "state": "required dict<string, string>"
        },
        "return": "nonempty dict"
    },
    "phragment.queryfragments": {
        "description": "Query fragments based on their paths.",
        "params": {
            "paths": "required list<string>"
        },
        "return": "nonempty dict"
    },
    "phriction.create": {
        "description": "Create a Phriction document.",
        "params": {
            "slug": "required string",
            "title": "required string",
            "content": "required string",
            "description": "optional string"
        },
        "return": "nonempty dict"
    },
    "phriction.edit": {
        "description": "Update a Phriction document.",
        "params": {
            "slug": "required string",
            "title": "optional string",
            "content": "optional string",
            "description": "optional string"
        },
        "return": "nonempty dict"
    },
    "phriction.history": {
        "description": "Retrieve history about a Phriction document.",
        "params": {
            "slug": "required string"
        },
        "return": "nonempty list"
    },
    "phriction.info": {
        "description": "Retrieve information about a Phriction document.",
        "params": {
            "slug": "required string"
        },
        "return": "nonempty dict"
    },
    "project.column.search": {
        "description": "Search for Workboard columns.",
        "params": {
            "ids": "optional list<int>",
            "phids": "optional list<phid>",
            "projects": "optional list<phid>"
        },
        "return": "list"
    },
    "project.create": {
        "description": "Create a project.",
        "params": {
            "name": "required string",
            "members": "optional list<phid>",
            "icon": "optional string",
            "color": "optional string",
            "tags": "optional list<string>"
        },
        "return": "dict"
    },
    "project.query": {
        "description": "Execute searches for Projects.",
        "params": {
            "ids": "optional list<int>",
            "names": "optional list<string>",
            "phids": "optional list<phid>",
            "slugs": "optional list<string>",
            "icons": "optional list<string>",
            "colors": "optional list<string>",
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-closed\", \"status-active\", \"status-archived\">",
            "members": "optional list<phid>",
            "limit": "optional int",
            "offset": "optional int"
        },
        "return": "list"
    },
    "project.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.",
        "params": {
            "transactions": "list<map<string, wild>>",
            "objectIdentifier": "optional id|phid|string"
        },
        "return": "map<string, wild>"
    },
    "project.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "releeph.getbranches": {
        "description": "Return information about all active Releeph branches.",
        "params": [],
        "return": "nonempty list<dict<string, wild>>"
    },
    "releeph.querybranches": {
        "description": "Query information about Releeph branches.",
        "params": {
            "ids": "optional list<id>",
            "phids": "optional list<phid>",
            "productPHIDs": "optional list<phid>",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "query-results"
    },
    "releeph.queryproducts": {
        "description": "Query information about Releeph products.",
        "params": {
            "ids": "optional list<id>",
            "phids": "optional list<phid>",
            "repositoryPHIDs": "optional list<phid>",
            "isActive": "optional bool",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "query-results"
    },
    "releeph.queryrequests": {
        "description": "Return information about all Releeph requests linked to the given ids.",
        "params": {
            "revisionPHIDs": "optional list<phid>",
            "requestedCommitPHIDs": "optional list<phid>"
        },
        "return": "dict<string, wild>"
    },
    "releeph.request": {
        "description": "Request a commit or diff to be picked to a branch.",
        "params": {
            "branchPHID": "required string",
            "things": "required list<string>",
            "fields": "dict<string, string>"
        },
        "return": "dict<string, wild>"
    },
    "releephwork.canpush": {
        "description": "Return whether the conduit user is allowed to push.",
        "params": {
            "projectPHID": "required string"
        },
        "return": "bool"
    },
    "releephwork.getauthorinfo": {
        "description": "Return a string to use as the VCS author.",
        "params": {
            "userPHID": "required string",
            "vcsType": "required string"
        },
        "return": "nonempty string"
    },
    "releephwork.getbranch": {
        "description": "Return information to help checkout / cut a Releeph branch.",
        "params": {
            "branchPHID": "required string"
        },
        "return": "dict<string, wild>"
    },
    "releephwork.getbranchcommitmessage": {
        "description": "Get a commit message for committing a Releeph branch.",
        "params": {
            "branchPHID": "required string"
        },
        "return": "nonempty string"
    },
    "releephwork.getcommitmessage": {
        "description": "Get commit message components for building a ReleephRequest commit message.",
        "params": {
            "requestPHID": "required string",
            "action": "required string-constant<\"pick\", \"revert\">"
        },
        "return": "dict<string, string>"
    },
    "releephwork.nextrequest": {
        "description": "Return info required to cut a branch, and pick and revert ReleephRequests.",
        "params": {
            "branchPHID": "required phid",
            "seen": "required map<string, bool>"
        },
        "return": ""
    },
    "releephwork.record": {
        "description": "Record whether we committed a pick or revert to the upstream repository.",
        "params": {
            "requestPHID": "required string",
            "action": "required string-constant<\"pick\", \"revert\">",
            "commitIdentifier": "required string"
        },
        "return": "void"
    },
    "releephwork.recordpickstatus": {
        "description": "Record whether a pick or revert was successful or not.",
        "params": {
            "requestPHID": "required string",
            "action": "required string-constant<\"pick\", \"revert\">",
            "ok": "required bool",
            "dryRun": "optional bool",
            "details": "optional dict<string, wild>"
        },
        "return": ""
    },
    "remarkup.process": {
        "description": "Process text through remarkup in Phabricator context.",
        "params": {
            "context": "required string-constant<\"phriction\", \"maniphest\", \"differential\", \"phame\", \"feed\", \"diffusion\">",
            "contents": "required list<string>"
        },
        "return": "nonempty dict"
    },
    "repository.query": {
        "description": "Query repositories.",
        "params": {
            "ids": "optional list<int>",
            "phids": "optional list<phid>",
            "callsigns": "optional list<string>",
            "vcsTypes": "optional list<string>",
            "remoteURIs": "optional list<string>",
            "uuids": "optional list<string>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "list<dict>"
    },
    "slowvote.info": {
        "description": "Retrieve an array of information about a poll.",
        "params": {
            "poll_id": "required id"
        },
        "return": "nonempty dict"
    },
    "token.give": {
        "description": "Give or change a token.",
        "params": {
            "tokenPHID": "phid|null",
            "objectPHID": "phid"
        },
        "return": "void"
    },
    "token.given": {
        "description": "Query tokens given to objects.",
        "params": {
            "authorPHIDs": "list<phid>",
            "objectPHIDs": "list<phid>",
            "tokenPHIDs": "list<phid>"
        },
        "return": "list<dict>"
    },
    "token.query": {
        "description": "Query tokens.",
        "params": [],
        "return": "list<dict>"
    },
    "user.disable": {
        "description": "Permanently disable specified users (admin only).",
        "params": {
            "phids": "required list<phid>"
        },
        "return": "void"
    },
    "user.enable": {
        "description": "Re-enable specified users (admin only).",
        "params": {
            "phids": "required list<phid>"
        },
        "return": "void"
    },
    "user.query": {
        "description": "Query users.",
        "params": {
            "usernames": "optional list<string>",
            "emails": "optional list<string>",
            "realnames": "optional list<string>",
            "phids": "optional list<phid>",
            "ids": "optional list<uint>",
            "offset": "optional int",
            "limit": "optional int (default = 100)"
        },
        "return": "list<dict>"
    },
    "user.whoami": {
        "description": "Retrieve information about the logged-in user.",
        "params": [],
        "return": "nonempty dict<string, wild>"
    },
    "user.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Search+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.",
        "params": {
            "queryKey": "optional string",
            "constraints": "optional map<string, wild>",
            "attachments": "optional map<string, bool>",
            "order": "optional order",
            "before": "optional string",
            "after": "optional string",
            "limit": "optional int (default = 100)"
        },
        "return": "map<string, wild>"
    },
    "user.find": {
        "description": "Lookup PHIDs by username. Obsoleted by \"user.query\".",
        "params": {
            "aliases": "required list<string>"
        },
        "return": "nonempty dict<string, phid>"
    }
}